Проект содержит в себе две игры:
- Тетрис
- Змейка

Для реализации игры «Змейка» проект состоит из двух отдельных компонентов: библиотеки, отвечающей за реализацию логики игры, и десктопного графического интерфейса.
Разработанную библиотеку подключена к консольному интерфейсу из BrickGame v1.0. Консольный интерфейс полностью поддерживает новую игру. \
Разработанную в BrickGame v1.0 игру «Тетрис» подключила к десктопному интерфейсу, разработанному в данном проекте. Он  полностью поддерживает игру. \


Игрок управляет змейкой, которая непрерывно движется вперед. Игрок изменяет направление движения змейки с помощью стрелок. Цель игры заключается в сборе «яблок», появляющихся на игровом поле. При этом игрок не должен касаться стенок игрового поля. После «поедания» очередного «яблока» длина змейки увеличивается на один. Игрок побеждает, если змейка достигает максимального размера (200 «пикселей»). Если змейка сталкивается с границей игрового поля, то игрок проигрывает.
Игра была разработана на основе другой, которая называлась Blockage. В ней два игрока управляли персонажами, оставлявшими след, в который нельзя было врезаться. Игрок, продержавшийся дольше, побеждал. В 1977 компания Atari выпустила игру Worm, в которую играл уже только один игрок. Самой популярной версией игры может считаться версия 1997, выпущенная шведской компанией Nokia для их телефона Nokia 6110 и разработанная Taneli Armanto.

Паттерн MVC
Паттерн MVC (Model-View-Controller, Модель-Представление-Контроллер) представляет собой схему разделения модулей приложения на три отдельных макрокомпонента: модель, содержащую в себе бизнес-логику, представление — форму пользовательского интерфейса для осуществления взаимодействия с программой и контроллер, осуществляющий модификацию модели по действию пользователя.
Концепция MVC была описана Трюгве Реенскаугом в 1978 году, работавшем в научно-исследовательском центре «Xerox PARC» над языком программирования «Smalltalk». Позже Стив Бурбек реализовал шаблон в Smalltalk-80. Окончательная версия концепции MVC была опубликована лишь в 1988 году в журнале Technology Object. Впоследствии шаблон проектирования стал эволюционировать. Например, была представлена иерархическая версия HMVC, MVA и MVVM.
Основная необходимость возникновения этого паттерна связана с желанием разработчиков отделить бизнес-логику программы от представлений, что позволяет легко заменять представления и переиспользовать реализованную единожды логику в других условиях. Отделенная от представления модель и контроллер для взаимодействия с ней позволяет эффективно переиспользовать или модифицировать уже написанный код.
Модель хранит и осуществляет доступ к основным данным, производит по запросам операции, определенные бизнес-логикой программы, то есть руководит той частью программы, которая отвечает за все алгоритмы и процессы обработки информации. Данные модели, изменяясь под действием контроллера, влияют на отображение информации на представлении пользовательского интерфейса. В качестве модели в данной программе должна выступить библиотека классов, осуществляющая логику игры змейка. Эта библиотека должна предоставлять все необходимые классы и методы для осуществления механики игры. Это и есть бизнес-логика данной программы, так как предоставляет средства для решения задачи.
Контроллер — тонкий макрокомпонент, который осуществляет модификацию модели. Через него формируются запросы на изменение модели. В коде это выглядит, как некий «фасад» для модели, то есть набор методов, которые уже работают напрямую с моделью. Тонким он называется потому, что идеальный контроллер не содержит в себе никакой дополнительной логики, кроме вызова одного или нескольких методов модели. Контроллер выполняет функцию связующего элемента между интерфейсом и моделью. Это позволяет полностью инкапсулировать модель от отображения. Такое разделение полезно в силу того, что позволяет коду представления ничего не знать о коде модели и обращаться к одному лишь контроллеру, интерфейс предоставляемых функций которого, вероятно, не будет значительно меняться. Модель же может претерпевать значительные изменения, и, при «переезде» на другие алгоритмы, технологии или даже языки программирования в модели, потребуется поменять лишь небольшой участок кода в контроллере, непосредственно связанный с моделью. В противном случае, вероятнее всего, пришлось бы переписывать значительную часть кода интерфейса, так как он сильно зависел бы от реализации модели. Таким образом, взаимодействуя с интерфейсом, пользователь вызывает методы контроллера, которые модифицируют модель.
К представлению относится весь код, связанный с интерфейсом программы. В коде идеального интерфейса не должно быть никакой бизнес-логики. Он только представляет форму для взаимодействия с пользователем.


Паттерн MVP
Паттерн MVP имеет два общих компонента с MVC: модель и представление. Но он заменяет контроллер на презентер.
Презентер реализует взаимодействие между моделью и представлением. Когда представление уведомляет презентер, что пользователь что-то сделал (например, нажал кнопку), презентер принимает решение об обновлении модели и синхронизирует все изменения между моделью и представлением. Однако презентер не общается с представлением напрямую. Вместо этого он общается через интерфейс. Благодаря чему все компоненты приложения впоследствии могут быть протестированы по отдельности.


Паттерн MVVM
MVVM — это более современная эволюция MVC. Основная цель MVVM — обеспечить четкое разделение между уровнями представления и модели.
MVVM поддерживает двустороннюю привязку данных между компонентами View и ViewModel.
Представление выступает подписчиком на события изменения значений свойств предоставляемых моделью представления (ViewModel). В случае если в модели представления изменилось какое-либо свойство, то она оповещает всех подписчиков об этом, и представление, в свою очередь, запрашивает обновлённое значение свойства из модели представления. В случае если пользователь воздействует на какой-либо элемент интерфейса, представление вызывает соответствующую команду, предоставленную моделью представления.
Модель представления — с одной стороны, абстракция представления, а с другой — обертка данных из модели, подлежащих связыванию. То есть она содержит модель, преобразованную к представлению, а также команды, которыми может пользоваться представление, чтобы влиять на модель.